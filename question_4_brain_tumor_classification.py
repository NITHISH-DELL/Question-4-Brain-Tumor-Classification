# -*- coding: utf-8 -*-
"""Question-4 Brain Tumor classification

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ovFHVxrNDMcGTmYZYoH6bMSTibfNOvJL

**importing the dataset and preprocessing the data**
"""

import os
import matplotlib.image as img
import numpy as np
from PIL import Image
import pandas as pd
 
# provide the location of image and CSV file for reading 
filePath = "/content/drive/MyDrive/curneu/Question 4/DS-IQ-004-Braintumor/Qn3_Braintumor/Brain Tumor"
data = pd.read_csv("/content/drive/MyDrive/curneu/Question 4/DS-IQ-004-Braintumor/Qn3_Braintumor/Brain Tumor.csv")
data_array = data.values

#loading the images and the dataset
def load_images(path):
    images = []
    label=[]
    for dirname, _, filenames in os.walk(path): # Iterating through Each file in the path
        for filename in filenames:
            image = img.imread(os.path.join(dirname, filename))#getting the images
            image_resized = np.array(Image.fromarray(image).resize((128,128)))# resizing into 128,128
            image_resized = image_resized.astype('float32')# converting into float 
            image_resized = image_resized/255.0 # scaling the image
            images.append(image)# appending into a new list
          
            for i in range(len(data_array)):
              if data_array[i][0] == filename[:-4]:# comparing the Image name column of dataset with actual image name for getting the respective target in image reading order
                label.append(data_array[i][1])# appending the target into list.

            
    return np.array(images),label

images,labels = load_images(filePath)

print(images)

print(labels)

image2 = []
for i in range(len(images)):
  image2.append(images[i].flatten())# flattening the images into 1D array
image3 = np.array(image2)# converting images into numpy array

label2 = np.array(labels)# converting labels into numpy array
label2.shape

print(len(image2),len(image2[0]))
print(len(labels))

"""**Displaying the sample image**"""

import matplotlib.pyplot as plt
import matplotlib.image as mpimg 
imgplot = plt.imshow(images[1])# displaying the sample image
plt.show()

print(data.shape)

normalized_dataset = (image3 - np.min(image3)) / (np.max(image3) - np.min(image3))
print(normalized_dataset) # normalizing the image data

X_train = normalized_dataset.T # transpose of image data
Y_train = label2.reshape(1, X_train.shape[1])# reshaping of target

print("Shape of X_train : ", X_train.shape)
print("Shape of Y_train : ", Y_train.shape)

"""**Implementing with Logistic Regression and training the model**"""

def sigmoid(x):
    return 1/(1 + np.exp(-x))

def model(X, Y, learning_rate, iterations): # logistic regresion model is used for training to classify the
    
    m = X_train.shape[1]
    n = X_train.shape[0]

    
    W = np.zeros((n,1))
    B = 0
    
    cost_list = []
    
    for i in range(iterations):
        
        Z = np.dot(W.T, X) + B
        A = sigmoid(Z)
        # cost function
        cost = -(1/m)*np.sum( Y*np.log(A) + (1-Y)*np.log(1-A))
        
        # Gradient Descent
        dW = (1/m)*np.dot(A-Y, X.T)
        dB = (1/m)*np.sum(A - Y)
        
        W = W - learning_rate*dW.T
        B = B - learning_rate*dB
        
        # Keeping track of our cost function value
        cost_list.append(cost)
        
        
        print("cost after ", i, "iteration is : ", cost)
        
    return W, B, cost_list

iteration = 1000
learning_rate = 0.0015
W, B, cost_list = model(X_train, Y_train, learning_rate = learning_rate, iterations = iteration) # passsing the parameters for training

# cost value got after the traning the model
print(cost_list[-1])

# ploting the cost value for the training of the model.
plt.plot(np.arange(iteration), cost_list)
plt.show()

"""**Testing the model**"""

# provide the location of image and CSV file for reading 
filePath = "/content/drive/MyDrive/curneu/Question 4/DS-IQ-004-Braintumor/Qn3_Braintumor/Brain Tumor"
data = pd.read_csv("/content/drive/MyDrive/curneu/Question 4/DS-IQ-004-Braintumor/Qn3_Braintumor/bt_dataset_t3.csv")
data_array = data.values

#loading the images and the dataset
def load_images(path):
    images = []
    label = []

  
    for dirname, _, filenames in os.walk(path): # Iterating through Each file in the path
        for filename in filenames:
            image = img.imread(os.path.join(dirname, filename))#getting the images
            image_resized = np.array(Image.fromarray(image).resize((128,128)))# resizing into 128,128
            image_resized = image_resized.astype('float32')# converting into float 
            image_resized = image_resized/255.0 # scaling the image
            
          
            for i in range(len(data_array)):
              if data_array[i][0] == filename[:-4]:# comparing the Image name column of dataset with actual image name for getting the respective target in image reading order
                label.append(data_array[i][-1])# appending the target into list.
                images.append(image)#appending the images into list
              

            
    return np.array(images),label

images,labels = load_images(filePath)

data.head()

print(labels)

image2 = []
for i in range(len(images)):
  image2.append(images[i].flatten())# flattening the images into 1D array
image3 = np.array(image2)# converting the image into numpy array

label2 = np.array(labels)# converting the labels into numpy array
label2.shape

print(len(image2),len(image2[0]))
print(len(labels))

import matplotlib.pyplot as plt
import matplotlib.image as mpimg
imgplot = plt.imshow(images[1])# displaying the random image
plt.show()

normalized_dataset = (image3 - np.min(image3)) / (np.max(image3) - np.min(image3)) # normalizing the image data
print(normalized_dataset)

X_test = normalized_dataset.T #transpose of the images data
Y_test = label2.reshape(1, X_test.shape[1])

print("Shape of X_train : ", X_test.shape)
print("Shape of Y_train : ", Y_test.shape)

# testing the image data
def accuracy(X, Y, W, B):
    
    Z = np.dot(W.T, X) + B
    A = sigmoid(Z)
    
    A = A > 0.5
    
    A = np.array(A, dtype = 'int64')
    
    acc = (1 - np.sum(np.absolute(A - Y))/Y.shape[1])*100
    
    print("Accuracy of the model is : ", round(acc, 2), "%")

# getting the accuracy of testing
accuracy(X_test, Y_test, W, B)

